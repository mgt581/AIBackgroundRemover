package com.aiphotostudio.bgremover\n\nimport android.annotation.SuppressLint\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport android.util.Log\nimport android.view.View\nimport android.webkit.ValueCallback\nimport android.webkit.WebChromeClient\nimport android.webkit.WebResourceRequest\nimport android.webkit.WebResourceResponse\nimport android.webkit.WebSettings\nimport android.webkit.WebView\nimport android.webkit.WebViewClient\nimport android.widget.Button\nimport android.widget.TextView\nimport android.widget.Toast\nimport androidx.activity.OnBackPressedCallback\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.appcompat.app.AlertDialog\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.content.FileProvider\nimport com.google.firebase.auth.FirebaseAuth\nimport java.io.File\nimport java.text.SimpleDateFormat\nimport java.util.Date\nimport java.util.Locale\n\n/**\n * Main Activity for the AI Background Remover application.\n * Manages the primary WebView and synchronizes native authentication with it.\n */\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var auth: FirebaseAuth\n    private lateinit var backgroundWebView: WebView\n    private var filePathCallback: ValueCallback<Array<Uri>>? = null\n    private var cameraImageUri: Uri? = null\n\n    private lateinit var tvAuthStatus: TextView\n    private lateinit var btnHeaderLogin: Button\n\n    private val galleryLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\n        filePathCallback?.onReceiveValue(if (uri != null) arrayOf(uri) else null)\n        filePathCallback = null\n    }\n\n    private val cameraLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) { success: Boolean ->\n        if (success && cameraImageUri != null) {\n            filePathCallback?.onReceiveValue(arrayOf(cameraImageUri!!))\n        } else {\n            filePathCallback?.onReceiveValue(null)\n        }\n        filePathCallback = null\n    }\n\n    @SuppressLint(\"SetJavaScriptEnabled\")\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        auth = FirebaseAuth.getInstance()\n        initViews()\n        setupClickListeners()\n        setupWebView()\n        setupBackNavigation()\n    }\n\n    override fun onResume() {\n        super.onResume()\n        updateHeaderUi()\n        injectNativeConfig() // Re-inject on resume\n    }\n\n    private fun initViews() {\n        tvAuthStatus = findViewById(R.id.tv_auth_status)\n        btnHeaderLogin = findViewById(R.id.btn_header_login)\n        backgroundWebView = findViewById(R.id.backgroundWebView)\n    }\n\n    private fun setupClickListeners() {\n        btnHeaderLogin.setOnClickListener {\n            if (auth.currentUser != null) {\n                auth.signOut()\n                updateHeaderUi()\n                backgroundWebView.reload()\n            } else {\n                startActivity(Intent(this, LoginActivity::class.java))\n            }\n        }\n    }\n\n    @SuppressLint(\"SetJavaScriptEnabled\")\n    private fun setupWebView() {\n        backgroundWebView.apply {\n            settings.apply {\n                javaScriptEnabled = true\n                domStorageEnabled = true\n                databaseEnabled = true\n                mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW\n                allowFileAccess = true\n            }\n\n            val webInterface = WebAppInterface(\n                context = this@MainActivity,\n                onBackgroundPickerRequested = { runOnUiThread { showImageSourceDialog() } },\n                onGoogleSignInRequested = { runOnUiThread { startActivity(Intent(this@MainActivity, LoginActivity::class.java)) } },\n                onLoginRequested = { runOnUiThread { startActivity(Intent(this@MainActivity, LoginActivity::class.java)) } },\n                onLoginSuccess = { runOnUiThread { backgroundWebView.reload() } },\n                callback = { success, message ->\n                    runOnUiThread {\n                        val toastMessage = if (success) getString(R.string.saved_to_gallery) else message ?: getString(R.string.save_failed)\n                        Toast.makeText(this@MainActivity, toastMessage, Toast.LENGTH_SHORT).show()\n                    }\n                }\n            )\n\n            addJavascriptInterface(webInterface, \"AndroidBridge\")\n            addJavascriptInterface(webInterface, \"Studio\")\n\n            webViewClient = object : WebViewClient() {\n                override fun onPageFinished(view: WebView?, url: String?) {\n                    super.onPageFinished(view, url)\n                    injectNativeConfig()\n                }\n\n                override fun shouldOverrideUrlLoading(view: WebView, request: WebResourceRequest): Boolean {\n                    val url = request.url.toString()\n                    if (url.contains(\"signin.html\") || url.contains(\"login\")) {\n                        if (auth.currentUser == null) {\n                            startActivity(Intent(this@MainActivity, LoginActivity::class.java))\n                        }\n                        return true // Stop the WebView from loading the web login page\n                    }\n                    return false // Let the WebView handle all other links\n                }\n            }\n\n            webChromeClient = object : WebChromeClient() {\n                override fun onShowFileChooser(webView: WebView?, callback: ValueCallback<Array<Uri>>?, params: FileChooserParams?): Boolean {\n                    filePathCallback = callback\n                    showImageSourceDialog()\n                    return true\n                }\n            }\n            loadUrl(\"https://mgt581.github.io/photo-static-main-3/\")\n        }\n    }\n\n    private fun injectNativeConfig() {\n        val user = auth.currentUser\n        val userId = user?.uid ?: \"\"\n        val userEmail = user?.email ?: \"\"\n\n        val script = \"\"\"\n            (function() {\n                console.log('Injecting Native Auth State. User ID: $userId');\n                \n                // Forcefully set auth info for the web app to use\n                window.NATIVE_AUTH_USER_ID = '$userId';\n                window.NATIVE_AUTH_EMAIL = '$userEmail';\n\n                if ('$userId' !== '') {\n                    localStorage.setItem('userId', '$userId');\n                    sessionStorage.setItem('userId', '$userId');\n                    // Trigger any JS function that re-checks auth\n                    if (window.onNativeAuthResolved) {\n                        window.onNativeAuthResolved('$userId', '$userEmail');\n                    }\n                }\n\n                // Hide all web-based login elements permanently\n                var style = document.createElement('style');\n                style.innerHTML = \`.auth-container, .login-btn, .signup-btn, #auth-section, [href*=\"signin.html\"] { display: none !important; }\`;\n                document.head.appendChild(style);\n            })();\n        \"\"\".trimIndent()\n        \n        backgroundWebView.evaluateJavascript(script, null)\n    }\n\n    private fun showImageSourceDialog() {\n        val options = arrayOf(getString(R.string.take_photo), getString(R.string.choose_from_gallery), getString(R.string.cancel))\n        AlertDialog.Builder(this)\n            .setTitle(R.string.select_image_source)\n            .setItems(options) { dialog, which ->\n                when (which) {\n                    0 -> openCamera()\n                    1 -> galleryLauncher.launch(\"image/*\")\n                    else -> dialog.dismiss()\n                }\n            }.show()\n    }\n\n    private fun openCamera() {\n        val photoFile = File(getExternalFilesDir(null), \"IMG_${System.currentTimeMillis()}.jpg\")\n        cameraImageUri = FileProvider.getUriForFile(this, \"${packageName}.fileprovider\", photoFile)\n        cameraLauncher.launch(cameraImageUri)\n    }\n\n    private fun setupBackNavigation() {\n        onBackPressedDispatcher.addCallback(this, object : OnBackPressedCallback(true) {\n            override fun handleOnBackPressed() {\n                if (backgroundWebView.canGoBack()) {\n                    backgroundWebView.goBack()\n                } else {\n                    isEnabled = false\n                    onBackPressedDispatcher.onBackPressed()\n                }\n            }\n        })\n    }\n\n    private fun updateHeaderUi() {\n        val user = auth.currentUser\n        if (user != null) {\n            tvAuthStatus.visibility = View.VISIBLE\n            tvAuthStatus.text = user.email ?: getString(R.string.signed_in)\n            btnHeaderLogin.text = getString(R.string.sign_out)\n        } else {\n            tvAuthStatus.visibility = View.GONE\n            btnHeaderLogin.text = getString(R.string.sign_in)\n        }\n    }\n\n    companion object {\n        private const val TAG = \"MainActivity\"\n    }\n}\n